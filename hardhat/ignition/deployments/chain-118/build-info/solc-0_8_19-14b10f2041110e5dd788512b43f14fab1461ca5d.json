{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_19-14b10f2041110e5dd788512b43f14fab1461ca5d",
  "solcVersion": "0.8.19",
  "solcLongVersion": "0.8.19+commit.7dd6d404",
  "userSourceNameMap": {
    "contracts/ParallelLike.sol": "project/contracts/ParallelLike.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "paris",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@arcologynetwork/concurrentlib/=npm/@arcologynetwork/concurrentlib@2.2.0/"
      ]
    },
    "sources": {
      "npm/@arcologynetwork/concurrentlib@2.2.0/lib/commutative/U256Cum.sol": {
        "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0;\n\n/**\n * @author Arcology Network\n * @title U256Cumulative\n * @dev The U256Cumulative contract is an integer designed for cumulative operations in full concurrency. \n * It has both minimum and maximum bounds and allows concurrent delta changes as long as they are not mixed \n * with timing-dependent opeartions like reads ensuring thread safety. It is crucial to note that out-of-limit \n * delta changes will fail to ensure that the variable stays within its prescribed bounds.\n */\ncontract U256Cumulative {\n    address constant public API = address(0x85);    \n\n    /**\n     * @notice Constructor to initialize the U256Cumulative variable with specified minimum and maximum bounds.\n     * @param minv The minimum bound of the cumulative value.\n     * @param maxv The maximum bound of the cumulative value.\n     */\n    constructor (uint256 minv, uint256 maxv) {\n        (bool success,) = address(API).call(abi.encodeWithSignature(\"New(uint256, uint256, uint256)\", minv, maxv));\n        assert(success);\n    }\n\n    /**\n     * @notice Get the current value of the cumulative variable.\n     * @return The current value of the cumulative variable.\n     */\n    function get() public view returns(uint256) {  \n        (,bytes memory data) = address(API).staticcall(abi.encodeWithSignature(\"get()\"));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Add the given value to the cumulative variable.\n     * @param delta The value to be added to the cumulative variable.\n     * @return A boolean indicating the success of the operation.\n     */\n    function add(uint256 delta) public returns(bool) { \n        (bool success,) = address(API).call(abi.encodeWithSignature(\"add(uint256)\", delta));\n        return success; \n    }\n\n    /**\n     * @notice Subtract the given value from the cumulative variable.\n     * @param delta The value to be subtracted from the cumulative variable.\n     * @return A boolean indicating the success of the operation.\n     */\n    function sub(uint256 delta) public returns(bool) { \n        (bool success,) = address(API).call(abi.encodeWithSignature(\"sub(uint256)\", delta));\n        return success;\n    }   \n\n    /**\n     * @notice Get the minimum bound of the cumulative variable.\n     * @return The minimum bound of the cumulative variable.\n     */\n    function min() public  returns(uint256) { \n        (, bytes memory data) = address(API).staticcall(abi.encodeWithSignature(\"min()\"));\n        return abi.decode(data, (uint256));\n    }  \n\n    /**\n     * @notice Get the maximum bound of the cumulative variable.\n     * @return The maximum bound of the cumulative variable.\n     */\n    function max() public returns(uint256) { \n        (, bytes memory data) = address(API).staticcall(abi.encodeWithSignature(\"max()\"));\n        return abi.decode(data, (uint256));\n    }    \n}\n"
      },
      "project/contracts/ParallelLike.sol": {
        "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0;\n\nimport \"@arcologynetwork/concurrentlib/lib/commutative/U256Cum.sol\";\n\n// This is a simple contract that allows users to like and retrieve the number of likes.\n// It supports concurrent calls to the like function is OK.\ncontract ParallelLike {\n    U256Cumulative total = new U256Cumulative(0, type(uint256).max); // Using a commutative counter to store the number of likes.\n\n    //Increments the number of total by 1. Concurrent calls to this function is OK\n    function like() public {\n        total.add(1);\n    }\n\n    //Returns the number of likes\n    function getTotal() public view returns (uint256) {\n        return total.get();\n    }\n}\n"
      }
    }
  }
}