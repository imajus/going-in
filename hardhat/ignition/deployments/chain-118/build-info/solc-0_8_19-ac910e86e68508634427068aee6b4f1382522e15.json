{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_19-ac910e86e68508634427068aee6b4f1382522e15",
  "solcVersion": "0.8.19",
  "solcLongVersion": "0.8.19+commit.7dd6d404",
  "userSourceNameMap": {
    "contracts/ConcurrentERC20.sol": "project/contracts/ConcurrentERC20.sol",
    "contracts/TicketingCore.sol": "project/contracts/TicketingCore.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "paris",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@arcologynetwork/concurrentlib/=npm/@arcologynetwork/concurrentlib@2.2.0/",
        "project/:@arcologynetwork/concurrentlib/=npm/@arcologynetwork/concurrentlib@2.2.0/",
        "project/:@arcologynetwork/concurrentlib/=npm/@arcologynetwork/concurrentlib@2.2.0/",
        "project/:@arcologynetwork/concurrentlib/=npm/@arcologynetwork/concurrentlib@2.2.0/",
        "project/:@arcologynetwork/concurrentlib/=npm/@arcologynetwork/concurrentlib@2.2.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@4.9.6/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@4.9.6/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@4.9.6/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@4.9.6/"
      ]
    },
    "sources": {
      "npm/@arcologynetwork/concurrentlib@2.2.0/lib/commutative/U256Cum.sol": {
        "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0;\n\n/**\n * @author Arcology Network\n * @title U256Cumulative\n * @dev The U256Cumulative contract is an integer designed for cumulative operations in full concurrency. \n * It has both minimum and maximum bounds and allows concurrent delta changes as long as they are not mixed \n * with timing-dependent opeartions like reads ensuring thread safety. It is crucial to note that out-of-limit \n * delta changes will fail to ensure that the variable stays within its prescribed bounds.\n */\ncontract U256Cumulative {\n    address constant public API = address(0x85);    \n\n    /**\n     * @notice Constructor to initialize the U256Cumulative variable with specified minimum and maximum bounds.\n     * @param minv The minimum bound of the cumulative value.\n     * @param maxv The maximum bound of the cumulative value.\n     */\n    constructor (uint256 minv, uint256 maxv) {\n        (bool success,) = address(API).call(abi.encodeWithSignature(\"New(uint256, uint256, uint256)\", minv, maxv));\n        assert(success);\n    }\n\n    /**\n     * @notice Get the current value of the cumulative variable.\n     * @return The current value of the cumulative variable.\n     */\n    function get() public view returns(uint256) {  \n        (,bytes memory data) = address(API).staticcall(abi.encodeWithSignature(\"get()\"));\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Add the given value to the cumulative variable.\n     * @param delta The value to be added to the cumulative variable.\n     * @return A boolean indicating the success of the operation.\n     */\n    function add(uint256 delta) public returns(bool) { \n        (bool success,) = address(API).call(abi.encodeWithSignature(\"add(uint256)\", delta));\n        return success; \n    }\n\n    /**\n     * @notice Subtract the given value from the cumulative variable.\n     * @param delta The value to be subtracted from the cumulative variable.\n     * @return A boolean indicating the success of the operation.\n     */\n    function sub(uint256 delta) public returns(bool) { \n        (bool success,) = address(API).call(abi.encodeWithSignature(\"sub(uint256)\", delta));\n        return success;\n    }   \n\n    /**\n     * @notice Get the minimum bound of the cumulative variable.\n     * @return The minimum bound of the cumulative variable.\n     */\n    function min() public  returns(uint256) { \n        (, bytes memory data) = address(API).staticcall(abi.encodeWithSignature(\"min()\"));\n        return abi.decode(data, (uint256));\n    }  \n\n    /**\n     * @notice Get the maximum bound of the cumulative variable.\n     * @return The maximum bound of the cumulative variable.\n     */\n    function max() public returns(uint256) { \n        (, bytes memory data) = address(API).staticcall(abi.encodeWithSignature(\"max()\"));\n        return abi.decode(data, (uint256));\n    }    \n}\n"
      },
      "npm/@arcologynetwork/concurrentlib@2.2.0/lib/core/Const.sol": {
        "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0;\nimport \"../runtime/Runtime.sol\";\n\nlibrary Const {\n    uint8 public constant U256_CUM = 103; // Cumulative u256\n    uint8 public constant BYTES = 107;\n\n    address public constant CONTAINER_ADDR = address(0x84);\n    address public constant MULTIPROCESSOR_ADDR = address(0xb0);\n}"
      },
      "npm/@arcologynetwork/concurrentlib@2.2.0/lib/core/Gateway.sol": {
        "content": "pragma solidity >=0.7.0;\n\n/**\n * @author Arcology Network\n * @title Gateway Concurrent Container\n * @dev The Gateway contract is a concurrent container designed for concurrent operations,\n *      allowing elements to be added in different processes running in parallel without\n *      causing state conflicts. It provides functionalities for both key-value lookup and\n *      linear access.\n *\n *      The contract serves as a hybrid data structure, functioning as a map set behind the scenes.\n *      The order of elements is formed when any timing-dependent functions like \"delLast()\" or \"nonNilCount()\"\n *      are called. However, performing concurrent \"delLast()\" or getting the length is not recommended in\n *      a parallel environment, as these operations are timing-independent and may lead to conflicts. \n *      Transactions resulting conflicts will be reverted to protect the state consistency.\n *\n *      Delopers should exercise caution when accessing the container concurrently to avoid conflicts.\n */\ncontract Gateway {\n    address public API;\n\n    /**\n     * @notice Constructor to initiate communication with the external contract.\n     */\n    constructor (uint8 typeID , address APIAddr, bool isBlockBound) {\n        API = APIAddr; // Need to set the address for the other functions to work properly.\n        (bool success,) = address(API).call(abi.encodeWithSignature(\n            \"new(uint8,bool)\", uint8(typeID), isBlockBound)); // A false value indicates it is NOT a transient container.\n        require(success);\n    }\n\n    /**\n     * @notice Set the transient state of the container. If the container is transient, it is only\n     *         accessible within the current BLOCK. After the block is finalized, the container will\n     *         be reset automatically.\n     */\n    function markBlockScoped() public returns(uint256) {\n        (,bytes memory data) = eval(abi.encodeWithSignature(\"markBlockScoped()\"));\n        return abi.decode(data, (uint256));\n    } \n\n    function eval(bytes memory command) public returns(bool, bytes memory) {\n        return address(API).call(abi.encodeWithSignature(\"eval(bytes)\", command));  \n    }  \n}\n"
      },
      "npm/@arcologynetwork/concurrentlib@2.2.0/lib/core/Primitive.sol": {
        "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0;\nimport \"../runtime/Runtime.sol\";\nimport \"./Gateway.sol\";\nimport \"./Const.sol\";\n/**\n * @author Arcology Network\n * @title Base Concurrent Container\n * @dev The Base contract is a concurrent container designed for concurrent operations,\n *      allowing elements to be added in different processes running in parallel without\n *      causing state conflicts. It provides functionalities for both key-value lookup and\n *      linear access.\n *\n *      The contract serves as a hybrid data structure, functioning as a map set behind the scenes.\n *      The order of elements is formed when any timing-dependent functions like \"delLast()\" or \"nonNilCount()\"\n *      are called. However, performing concurrent \"delLast()\" or getting the length is not recommended in\n *      a parallel environment, as these operations are timing-independent and may lead to conflicts. \n *      Transactions resulting conflicts will be reverted to protect the state consistency.\n *\n *      Delopers should exercise caution when accessing the container concurrently to avoid conflicts.\n */\ncontract Base is Gateway{    \n    /**\n     * @notice Constructor to initiate communication with the external contract.\n     * @param typeID The type ID of the concurrent container.\n     * @param isBlockBound If true, the content of the container will be cleared after each block.\n     */\n    constructor (uint8 typeID, bool isBlockBound) Gateway(typeID, Const.CONTAINER_ADDR, isBlockBound) {}\n          \n    /**\n     * @notice Retrieve the length of the container, including newly appended and deleted values if any.\n     * @return The length of the container.\n     */\n    function fullLength() public returns(uint256) {\n        (,bytes memory data) = eval(abi.encodeWithSignature(\"fullLength()\"));\n        return abi.decode(data, (uint256));\n    }  \n\n    /**\n     * @notice Retrieve the total number of non nil element in the container.\n     * @return The total number of non-nil values in the container.\n     */\n    function nonNilCount() public returns(uint256) {\n        (,bytes memory data) = eval(abi.encodeWithSignature(\"length()\"));\n        return abi.decode(data, (uint256));\n    }\n     \n    /**\n     * @notice Retrieve the committed length of the container. This usually is the length after previous generation or block.\n     * @dev This function is used to get the length of the container after the last commit. \n     * @return The latest committed length of the container. This is function is thread-safe.\n     */\n    function committedLength() public returns(uint256) {\n        (,bytes memory data) = eval(abi.encodeWithSignature(\"committedLength()\"));\n        if (data.length > 0) {\n            return abi.decode(data, (uint256));   \n        }\n        return 0;    \n    }\n\n    /**\n     * @notice Removes and returns the last element of the container.\n     * @return The data of the removed element.\n     */\n    function _delLast() public virtual returns(bytes memory) {\n        (,bytes memory data) = eval(abi.encodeWithSignature(\"delLast()\"));\n        return data;\n    }\n    \n    /**\n     * @notice Delete the data at the given index in the container.\n     * @param idx The index of the data to be deleted.\n     * @return success true if the data was successfully deleted, false otherwise.\n     */\n    function del(uint256 idx) public virtual returns(bool) {\n        bytes memory key = indToKey(idx);\n        if (key.length == 0) {\n            return false;\n        }\n        return _del(key);\n    }\n    \n    /**\n     * @notice Delete the data associated with the given key from the container.\n     * @param key The key associated with the data to be deleted.\n     * @return success true if the data was successfully deleted, false otherwise.\n     */\n    function _del(bytes memory key) public returns(bool) {\n       (bool success,)  = eval(abi.encodeWithSignature(\"delByKey(bytes)\", key));\n       return success;\n    }\n    \n    /**\n     * @notice Delete all the elements.\n     * @return success true if the all the data was successfully deleted, false otherwise.\n     */\n    function clear() public returns(bool)  {\n        (bool success,)  = eval(abi.encodeWithSignature(\"clear()\"));\n        return success;       \n    }\n\n    /**\n     * @notice Delete all the committed elements. This will not change the length of committedLength() immediately.\n     * @return success true if the all the data was successfully deleted, false otherwise.\n     */\n    function clearCommitted() public returns(bool)  {\n        (bool success,)  = eval(abi.encodeWithSignature(\"clearCommitted()\"));\n        return success;       \n    }\n    \n    /**\n     * @notice Reset the data associated with the key to its default value.\n     * @param key The key associated with the data to be reset.\n     * @return success true if the data was successfully reset, false otherwise.\n     */\n    function _resetByKey(bytes memory key) public returns(bool) {\n       (bool success,) = eval(abi.encodeWithSignature(\"resetByKey(bytes)\", key));\n       return success;\n    }\n\n    /**\n     * @notice Reset the data associated at the index to its default value.\n     * @param idx The index associated with the data to be reset.\n     * @return success true if the data was successfully reset, false otherwise.\n     */\n    function resetByInd(uint256 idx) public returns(bool) {\n       (bool success,) = eval(abi.encodeWithSignature(\"resetByInd(uint256)\", idx));\n       return success;\n    }\n\n    /**\n     * @notice Retrieves the key associated with the given index in the concurrent container.\n     * @param idx The index for which to retrieve the key.\n     * @return The key associated with the given index.\n     */\n    function indToKey(uint256 idx) public returns(bytes memory) {\n        (, bytes memory data) = eval(abi.encodeWithSignature(\"indToKey(uint256)\", idx));\n        return data;  \n    }\n\n    /**\n     * @notice Retrieves the index associated with the given key in the concurrent container.\n     * @param key The key for which to retrieve the index.\n     * @return The index associated with the given key.\n     */\n    function keyToInd(bytes memory key) public returns(uint256) {\n        (, bytes memory data) = eval(abi.encodeWithSignature(\"keyToInd(bytes)\", key));   \n        return abi.decode(data,(uint256));     \n    }\n    \n    /**\n     * @notice Set the data at the given index in the container. It equals to append if the index is the length of the container.\n     * @param idx The index where the data should be stored.\n     * @param encoded The data to be stored.\n     * @return success true if the data was successfully updated, false otherwise.\n     */\n    function _set(uint256 idx, bytes memory encoded) public returns(bool) {\n        bytes memory key = indToKey(idx);\n        if (key.length == 0) {\n            return false;\n        }\n        return _set(key, encoded);\n    }\n\n    /**\n     * @notice Set the data associated with the given key in the container.\n     * @param key The key associated with the data.\n     * @param elem The data to be stored.\n     * @return success true if the data was successfully updated, false otherwise.\n     */\n    function _set(bytes memory key, bytes memory elem) public returns(bool) {\n        (bool success,) = eval(abi.encodeWithSignature(\"setByKey(bytes,bytes)\", key, elem));\n        return success;   \n    }\n\n    /**\n     * @notice Set the data associated with the given key in the container.\n     * @param key The key associated with the data.\n     * @param min The lower bound of the data to be stored.\n     * @param max The upper bound of the data to be stored.\n     * @return success true if the data was successfully updated, false otherwise.\n     */\n    function _init(bytes memory key, bytes memory min, bytes memory max) public returns(bool) {\n        (bool success,) = eval(abi.encodeWithSignature(\"init(bytes,bytes,bytes)\", key, min, max));\n        return success;   \n    }\n    \n    /**\n     * @notice Checks if a key exists in the the data structure. *\n     * @param key The key to check for existence.\n     * @return A boolean indicating whether the key exists in it or not.\n    */\n    function exists(bytes memory key) public returns(bool) {\n        (bool success,) = eval(abi.encodeWithSignature(\"getByKey(bytes)\", key));\n        return success;\n    }\n\n    /**\n     * @notice Checks if the index exists in the the data structure.\n     * @param idx The index to check for existence.\n     * @return A boolean indicating whether the key exists in it or not.\n    */\n    function exists(uint256 idx) public returns(bool) {\n        bytes memory key = indToKey(idx);\n        if (key.length == 0) {\n            return false;\n        }\n        return exists(key);\n    }\n    \n    /**\n     * @notice Retrieve the data at the given index from the container.\n     * @param idx The index of the data to retrieve.\n     * @return The data stored at the specified index.\n     */\n    function _get(uint256 idx) public returns(bool, bytes memory) {\n        return eval(abi.encodeWithSignature(\"getByIndex(uint256)\", idx)); \n    }\n\n    /**\n     * @notice Retrieve the data associated with the given key from the container.\n     * @param key The key associated with the data to retrieve.\n     * @return The data stored at the specified key.\n     */\n    function _get(bytes memory key) public returns(bool, bytes memory)  {\n        return eval(abi.encodeWithSignature(\"getByKey(bytes)\", key));  \n    }\n\n    /**\n     * @notice Retrieve the minimum entry stored in the container sorted by value numerically.\n     * @return encoded The minimum valu and the index.\n     */\n    function _min() public returns(bytes memory)  {\n        (,bytes memory data) = eval(abi.encodeWithSignature(\"min()\"));\n        return data;\n    }\n\n    /**\n     * @notice Retrieve the maximum entry stored in the container sorted by value numerically.\n     * @return The encoded maximum value and the index.\n     */\n    function _max() public returns(bytes memory)  {\n        (,bytes memory data) = eval(abi.encodeWithSignature(\"max()\"));\n        return data;\n    }\n\n    /**\n     * @notice Execute a custom operation on the container's data stored.\n     * @param data Arbitrary data to be used in the custom operation.\n     */\n    function invoke(bytes memory data) public returns(bool, bytes memory) {\n        return address(API).call(abi.encodeWithSignature(\"invoke(bytes)\", data));  \n    }\n\n    /**\n     * @notice Get a pseudo-random UUID from an external contract.\n     * @dev The UUID is a pseudo-random number generated by the external contract.\n     * @return The pseudo-random UUID returned by the external contract.\n     */\n    function uuid() public returns(bytes memory) {\n        return  Runtime.uuid(); \n    }\n}"
      },
      "npm/@arcologynetwork/concurrentlib@2.2.0/lib/map/U256.sol": {
        "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0;\n\nimport \"../core/Const.sol\"; \nimport \"../core/Primitive.sol\";\n\n/**\n * @author Arcology Network\n * @title U256U256Map Contract\n * @dev The U256U256Map contract provides a simple mapping structure to associate\n *      uint256 keys with uint256 values. It inherits from the \"Base\" contract\n *      to utilize container functionalities for key-value storage.\n */\ncontract U256Map is Base { \n    constructor() Base(Const.BYTES, false){}\n\n    /**\n     * @notice Check if a given key exists in the map.\n     * @param k The uint256 key to check for existence.\n     * @return true if the key exists, false otherwise.\n     */    \n    function exist(uint256 k) public returns(bool) { \n        return Base.exists(abi.encodePacked(k)); \n    }\n\n    /**\n     * @notice Set a key-value pair in the map.\n     * @param key The uint256 key to set.\n     * @param value The uint256 value associated with the key.\n     */\n    function set(uint256 key, uint256 value) public { \n        Base._set(abi.encodePacked(key), abi.encodePacked(value));       \n    }\n\n    /**\n     * @notice Get the value associated with a given key in the map.\n     * @param key The uint256 key to retrieve the associated value.\n     * @return value The uint256 value associated with the key.\n     */\n    function get(uint256 key) public virtual returns(uint256 value){    \n        (bool exist,bytes memory data)= Base._get(abi.encodePacked(key));\n        if(exist)\n            return uint256(abi.decode(data, (bytes32)));\n        else\n            return uint256(0);\n    }    \n\n    /**\n     * @notice Get the key based on it index.\n     * @param idx The key to retrieve the associated index.\n     * @return The index key associated with the index.\n     */\n    function keyAt(uint256 idx) public virtual returns(uint256) {    \n        return uint256(abi.decode(Base.indToKey(idx), (bytes32)) );        \n    }   \n\n    /**\n     * @notice Retrieves the value stored at the specified index.\n     * @param idx The index of the element to retrieve.\n     * @return value The value retrieved from the storage array at the given index.    \n     */\n    function valueAt(uint256 idx) public virtual returns(uint256 value){ \n        (bool exist,bytes memory data)=Base._get(idx);\n        if(exist)\n            return  uint256(abi.decode(data, (bytes32)));\n        else\n            return uint256(0);\n    }  \n\n    /**\n     * @notice Delete a key-value pair from the map.\n     * @param key The uint256 key to delete.\n     */\n    function del(uint256 key) public override returns(bool){ \n        return Base._del((abi.encodePacked(key)));  \n    }\n\n    /**\n     * @notice Retrieve the min value in the concurrent map.\n     * @return The minimum element by numerical comparison.\n     */\n    function min() public  returns(uint256, uint256, uint256) { \n        (uint256 idx, uint256 v) = abi.decode(Base._min(), (uint256, uint256));\n        return (keyAt(idx), idx, v);\n    }\n\n    /**\n     * @notice Retrieve the max value in the concurrent map.\n     * @return The maximum value by numerical comparison.\n     */\n    function max() public returns(uint256, uint256, uint256) { \n        (uint256 idx, uint256 v) = abi.decode(Base._max(), (uint256, uint256));\n        return (keyAt(idx), idx, v);\n    }\n}"
      },
      "npm/@arcologynetwork/concurrentlib@2.2.0/lib/runtime/Runtime.sol": {
        "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0;\n\n/**\n * @author Arcology Network\n * @title Runtime Library\n * @dev The Runtime Library provides runtime information to developers.\n *      It exposes functions to retrieve pseudo-process IDs (PIDs) and pseudo-random UUIDs.\n */\nlibrary Runtime {\n    /**\n     * @notice Get the pseudo-process ID (PID) from an external contract.\n     * @dev The PID is a pseudo-process ID and does not represent a real transaction being processed.\n     * @return args The pseudo-process ID (PID) returned by the external contract.\n     */\n    function pid() internal returns(bytes memory) {\n        (,bytes memory random) = address(0xa0).call(abi.encodeWithSignature(\"pid()\"));     \n        return random;\n    }\n\n    /**\n     * @notice Get a pseudo-random UUID from an external contract.\n     * @dev The UUID is a pseudo-random number generated by the external contract.\n     * @return The pseudo-random UUID returned by the external contract.\n     */\n    function uuid() internal returns(bytes memory) {\n        (,bytes memory id) = address(0xa0).call(abi.encodeWithSignature(\"uuid()\"));     \n        return id;\n    }\n  \n    /**\n     * @notice Call a custom operation.\n     * @return The result of the custom operation.\n     */\n    function eval(string memory func, bytes memory data) internal returns(bool, bytes memory) {\n        return address(0xa0).call(abi.encodeWithSignature(func, data)); \n    }\n\n    /**\n     * @notice Set the max parallelism level for a specific function with respect to other functions.\n     * @param others The list of function signatures and their contract address that can be executed in parallel.\n    */\n   function setParallelism(string memory funcName, address addr, bytes4[] memory others, uint64 parallelism) internal returns(bool) {\n        bytes4 funSign = bytes4(keccak256(bytes(funcName)));\n        (bool success,) = address(0xa0).call(abi.encodeWithSignature(\"setParallelism(bytes4,address,bytes4[],uint64)\", funSign, addr, others, parallelism));\n        return success;\n    }\n \n    /**\n     * @notice Get the number of concurrent instances of the specified function.\n     * @return The number of concurrent instances.\n     */\n    function isInDeferred() internal view returns(bool) {\n        (,bytes memory data) = address(0xa0).staticcall(abi.encodeWithSignature(\"isInDeferred()\"));\n        return abi.decode(data, (bool));  \n    }\n\n    /**\n     * @notice Inform the scheduler that a function needs to schedule a defer call. This function can only be called once in the constructor.\n     * @return The number of concurrent instances.\n     */\n    function defer(string memory funName, uint64 prepaidGas) internal returns(bool) {\n        bytes4 funSign = bytes4(keccak256(bytes(funName)));\n        (bool successful,) = address(0xa0).call(abi.encodeWithSignature(\"defer(bytes4,uint64)\", funSign, prepaidGas));\n        return successful;  \n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@4.9.6/security/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@4.9.6/token/ERC20/extensions/IERC20Metadata.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
      },
      "npm/@openzeppelin/contracts@4.9.6/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@4.9.6/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
      },
      "project/contracts/ConcurrentERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@arcologynetwork/concurrentlib/lib/commutative/U256Cum.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @title ConcurrentERC20\n * @notice ERC20 token implementation using Arcology's concurrent structures for parallel-safe operations\n * @dev Based on Arcology's ds-token pattern with U256Cumulative for balance tracking\n * Reference: https://github.com/arcology-network/examples/blob/main/ds-token/contracts/Token.sol\n */\ncontract ConcurrentERC20 is IERC20, IERC20Metadata, IERC165 {\n    // Token metadata\n    string private _name;\n    string private _symbol;\n\n    // Concurrent state variables\n    U256Cumulative private _totalSupply;\n    mapping(address => U256Cumulative) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    /**\n     * @notice Constructor to initialize token with name, symbol, and initial supply\n     * @param name_ Token name\n     * @param symbol_ Token symbol\n     * @param _initialSupply Initial supply minted to contract deployer\n     */\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint256 _initialSupply\n    ) {\n        _name = name_;\n        _symbol = symbol_;\n\n        // Initialize total supply with bounds [0, type(uint256).max]\n        _totalSupply = new U256Cumulative(0, type(uint256).max);\n\n        if (_initialSupply > 0) {\n            // Initialize deployer balance\n            _balances[msg.sender] = new U256Cumulative(0, type(uint256).max);\n\n            // Mint initial supply to deployer\n            _totalSupply.add(_initialSupply);\n            _balances[msg.sender].add(_initialSupply);\n\n            emit Transfer(address(0), msg.sender, _initialSupply);\n        }\n    }\n\n    /**\n     * @notice ERC-165 interface detection\n     * @dev Returns true if this contract implements the requested interface\n     * @param interfaceId The interface identifier (4 bytes)\n     * @return True if the interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC20).interfaceId ||\n               interfaceId == type(IERC20Metadata).interfaceId ||\n               interfaceId == type(IERC165).interfaceId;\n    }\n\n    /**\n     * @notice Get token name\n     * @return Token name\n     */\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @notice Get token symbol\n     * @return Token symbol\n     */\n    function symbol() public view override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @notice Get token decimals\n     * @return Number of decimals (18)\n     */\n    function decimals() public view override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @notice Get total token supply\n     * @return Current total supply\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply.get();\n    }\n\n    /**\n     * @notice Get balance of an account\n     * @param account Address to query\n     * @return Current balance\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        if (address(_balances[account]) == address(0)) {\n            return 0;\n        }\n        return _balances[account].get();\n    }\n\n    /**\n     * @notice Transfer tokens to another address\n     * @param to Recipient address\n     * @param amount Amount to transfer\n     * @return success True if transfer succeeded\n     */\n    function transfer(address to, uint256 amount) public override returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get allowance for spender\n     * @param owner Token owner address\n     * @param spender Spender address\n     * @return Current allowance\n     */\n    function allowance(\n        address owner,\n        address spender\n    ) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @notice Approve spender to use tokens\n     * @param spender Address to approve\n     * @param amount Amount to approve\n     * @return success True if approval succeeded\n     */\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        require(spender != address(0), \"ERC20: approve to zero address\");\n\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer tokens from one address to another using allowance\n     * @param from Source address\n     * @param to Destination address\n     * @param amount Amount to transfer\n     * @return success True if transfer succeeded\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public override returns (bool) {\n        uint256 currentAllowance = _allowances[from][msg.sender];\n        require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n\n        unchecked {\n            _allowances[from][msg.sender] = currentAllowance - amount;\n        }\n\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @notice Public mint function for testing purposes\n     * @dev In production, this should have access control\n     * @param to Address to mint tokens to\n     * @param amount Amount to mint\n     */\n    function mint(address to, uint256 amount) public {\n        require(to != address(0), \"ERC20: mint to zero address\");\n\n        // Initialize balance if needed\n        if (address(_balances[to]) == address(0)) {\n            _balances[to] = new U256Cumulative(0, type(uint256).max);\n        }\n\n        // Update total supply and recipient balance atomically\n        _totalSupply.add(amount);\n        _balances[to].add(amount);\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    /**\n     * @notice Internal transfer function using concurrent structures\n     * @param from Source address\n     * @param to Destination address\n     * @param amount Amount to transfer\n     */\n    function _transfer(address from, address to, uint256 amount) internal {\n        require(from != address(0), \"ERC20: transfer from zero address\");\n        require(to != address(0), \"ERC20: transfer to zero address\");\n\n        // Initialize sender balance if needed (should already exist)\n        require(\n            address(_balances[from]) != address(0),\n            \"ERC20: insufficient balance\"\n        );\n\n        // Initialize recipient balance if needed\n        if (address(_balances[to]) == address(0)) {\n            _balances[to] = new U256Cumulative(0, type(uint256).max);\n        }\n\n        // Perform atomic balance updates\n        // sub() will revert if balance falls below lower bound (0)\n        _balances[from].sub(amount);\n        _balances[to].add(amount);\n\n        emit Transfer(from, to, amount);\n    }\n}\n"
      },
      "project/contracts/ConcurrentERC721.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@arcologynetwork/concurrentlib/lib/runtime/Runtime.sol\";\nimport \"@arcologynetwork/concurrentlib/lib/map/U256.sol\";\nimport \"@arcologynetwork/concurrentlib/lib/commutative/U256Cum.sol\";\n\n/**\n * @title ConcurrentERC721\n * @notice Bare ERC-721 implementation using Arcology's concurrent structures for parallel-safe operations\n * @dev NO OpenZeppelin dependency to avoid read-after-write conflicts in parallel execution\n *\n * Key Features:\n * - Token IDs generated via Runtime.uuid() for guaranteed uniqueness in parallel mints\n * - U256Map for ownership tracking (tokenId → owner as uint160)\n * - mapping(address => U256Cumulative) for balance tracking (enables parallel balance updates)\n * - Standard mappings for approvals (single-tx operations, conflict-safe)\n * - Write-only mint operations (no reads after writes)\n * - Read-then-write pattern for transfers and burns\n *\n * ERC-721 Interface:\n * - balanceOf(address) → uint256\n * - ownerOf(uint256) → address\n * - transferFrom(address, address, uint256)\n * - safeTransferFrom(address, address, uint256)\n * - approve(address, uint256)\n * - setApprovalForAll(address, bool)\n * - getApproved(uint256) → address\n * - isApprovedForAll(address, address) → bool\n * - supportsInterface(bytes4) → bool (ERC-165)\n */\ncontract ConcurrentERC721 {\n    // ============ State Variables ============\n\n    // Metadata\n    string public name;\n    string public symbol;\n\n    // Concurrent data structures\n    U256Map private _owners; // tokenId → owner address (as uint160)\n    mapping(address => U256Cumulative) private _balances; // owner → balance counter (U256Cumulative)\n    U256Cumulative private _totalSupply; // Total number of tokens (minted - burned)\n\n    // Standard mappings for approvals (conflict-safe for single-tx operations)\n    mapping(uint256 => address) private _tokenApprovals; // tokenId → approved address\n    mapping(address => mapping(address => bool)) private _operatorApprovals; // owner → operator → approved\n\n    // Access control\n    address public immutable minter;\n\n    // ============ Events ============\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    // ============ Constructor ============\n\n    /**\n     * @notice Initialize NFT collection with concurrent structures\n     * @param name_ Token name (e.g., \"VIP Ticket\")\n     * @param symbol_ Token symbol (e.g., \"TICKET\")\n     */\n    constructor(string memory name_, string memory symbol_) {\n        name = name_;\n        symbol = symbol_;\n\n        // Initialize Arcology concurrent structures\n        _owners = new U256Map();\n        _totalSupply = new U256Cumulative(0, type(uint256).max);\n        // Note: _balances mapping entries are initialized on-demand in mint()\n\n        // Set minter to contract deployer (usually TicketingCore)\n        minter = msg.sender;\n    }\n\n    // ============ ERC-165 Interface Support ============\n\n    /**\n     * @notice Check if contract supports a given interface\n     * @param interfaceId Interface identifier\n     * @return bool True if interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId) public pure returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC-165\n            interfaceId == 0x80ac58cd || // ERC-721\n            interfaceId == 0x5b5e139f; // ERC-721 Metadata\n    }\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Get total number of tokens currently existing (minted - burned)\n     * @return Current total supply\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply.get();\n    }\n\n    /**\n     * @notice Get number of tokens owned by address\n     * @param owner Address to query\n     * @return Number of tokens owned\n     */\n    function balanceOf(address owner) public view returns (uint256) {\n        require(\n            owner != address(0),\n            \"ConcurrentERC721: balance query for zero address\"\n        );\n        // Return 0 if balance cumulative not initialized yet\n        if (address(_balances[owner]) == address(0)) {\n            return 0;\n        }\n        return _balances[owner].get();\n    }\n\n    /**\n     * @notice Get owner of a token\n     * @param tokenId Token ID to query\n     * @return Address of token owner\n     */\n    function ownerOf(uint256 tokenId) public returns (address) {\n        address owner = address(uint160(_owners.get(tokenId)));\n        require(\n            owner != address(0),\n            \"ConcurrentERC721: owner query for nonexistent token\"\n        );\n        return owner;\n    }\n\n    /**\n     * @notice Get approved address for a token\n     * @param tokenId Token ID to query\n     * @return Address approved to transfer this token\n     */\n    function getApproved(uint256 tokenId) public returns (address) {\n        require(\n            _exists(tokenId),\n            \"ConcurrentERC721: approved query for nonexistent token\"\n        );\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @notice Check if operator is approved for all tokens of owner\n     * @param owner Token owner address\n     * @param operator Operator address\n     * @return bool True if operator is approved\n     */\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) public view returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    // ============ Minting (Write-Only Pattern) ============\n\n    /**\n     * @notice Mint a new NFT with conflict-free UUID generation\n     * @dev Only callable by minter (TicketingCore contract)\n     * @dev Uses Runtime.uuid() for guaranteed unique token IDs in parallel execution\n     * @dev CRITICAL: Write-only operations - no reads after writes to prevent conflicts\n     * @param to Address to mint token to\n     * @return tokenId The ID of the newly minted token\n     */\n    function mint(address to) public returns (uint256) {\n        require(msg.sender == minter, \"ConcurrentERC721: caller is not minter\");\n        require(to != address(0), \"ConcurrentERC721: mint to zero address\");\n\n        // Generate unique token ID using Arcology's Runtime.uuid()\n        // This is conflict-free in parallel execution (each call gets unique UUID)\n        uint256 tokenId = uint256(keccak256(Runtime.uuid()));\n\n        // WRITE-ONLY OPERATIONS (no reads after this point)\n\n        // Set ownership (tokenId → owner as uint160)\n        _owners.set(tokenId, uint256(uint160(to)));\n\n        // Initialize balance cumulative if this is first token for this address\n        if (address(_balances[to]) == address(0)) {\n            _balances[to] = new U256Cumulative(0, type(uint256).max);\n        }\n\n        // Increment balance\n        _balances[to].add(1);\n\n        // Increment total supply\n        _totalSupply.add(1);\n\n        // Emit transfer event (mint from zero address)\n        emit Transfer(address(0), to, tokenId);\n\n        return tokenId;\n    }\n\n    // ============ Burning (Read-Then-Write Pattern) ============\n\n    /**\n     * @notice Burn an NFT\n     * @dev Can be called by token owner or approved address\n     * @dev CRITICAL: Read owner BEFORE any writes to prevent conflicts\n     * @param tokenId Token ID to burn\n     */\n    function burn(uint256 tokenId) public {\n        // READ PHASE: Get owner before any writes\n        address owner = ownerOf(tokenId);\n\n        // Verify authorization\n        require(\n            _isApprovedOrOwner(msg.sender, tokenId, owner),\n            \"ConcurrentERC721: caller is not owner nor approved\"\n        );\n\n        // WRITE PHASE: All writes happen after reads complete\n\n        // Delete ownership\n        _owners.del(tokenId);\n\n        // Decrement owner balance (must be initialized if they own a token)\n        _balances[owner].sub(1);\n\n        // Decrement total supply\n        _totalSupply.sub(1);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        // Emit transfer event (burn to zero address)\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    // ============ Transfers (Read-Then-Write Pattern) ============\n\n    /**\n     * @notice Transfer token from one address to another\n     * @dev CRITICAL: Read owner ONCE at start, then write-only operations\n     * @param from Current owner address\n     * @param to Recipient address\n     * @param tokenId Token ID to transfer\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public {\n        // READ PHASE: Get owner before any writes\n        address owner = ownerOf(tokenId);\n\n        // Verify 'from' matches actual owner\n        require(\n            owner == from,\n            \"ConcurrentERC721: transfer from incorrect owner\"\n        );\n\n        // Verify authorization\n        require(\n            _isApprovedOrOwner(msg.sender, tokenId, owner),\n            \"ConcurrentERC721: transfer caller is not owner nor approved\"\n        );\n\n        // Verify recipient is valid\n        require(to != address(0), \"ConcurrentERC721: transfer to zero address\");\n\n        // WRITE PHASE: All writes happen after reads complete\n\n        // Update ownership\n        _owners.set(tokenId, uint256(uint160(to)));\n\n        // Decrement sender balance (must be initialized if they own a token)\n        _balances[from].sub(1);\n\n        // Initialize recipient balance if needed\n        if (address(_balances[to]) == address(0)) {\n            _balances[to] = new U256Cumulative(0, type(uint256).max);\n        }\n\n        // Increment recipient balance\n        _balances[to].add(1);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        // Emit transfer event\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @notice Safe transfer with receiver check\n     * @param from Current owner address\n     * @param to Recipient address\n     * @param tokenId Token ID to transfer\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @notice Safe transfer with receiver check and data\n     * @param from Current owner address\n     * @param to Recipient address\n     * @param tokenId Token ID to transfer\n     * @param data Additional data to pass to receiver\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public {\n        transferFrom(from, to, tokenId);\n\n        // Check if recipient is a contract\n        if (to.code.length > 0) {\n            // Call onERC721Received if recipient is a contract\n            try\n                IERC721Receiver(to).onERC721Received(\n                    msg.sender,\n                    from,\n                    tokenId,\n                    data\n                )\n            returns (bytes4 retval) {\n                require(\n                    retval == IERC721Receiver.onERC721Received.selector,\n                    \"ConcurrentERC721: transfer to non ERC721Receiver implementer\"\n                );\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\n                        \"ConcurrentERC721: transfer to non ERC721Receiver implementer\"\n                    );\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n\n    // ============ Approvals (Standard Mappings - Conflict-Safe) ============\n\n    /**\n     * @notice Approve an address to transfer a specific token\n     * @param to Address to approve\n     * @param tokenId Token ID to approve\n     */\n    function approve(address to, uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n\n        require(to != owner, \"ConcurrentERC721: approval to current owner\");\n        require(\n            msg.sender == owner || isApprovedForAll(owner, msg.sender),\n            \"ConcurrentERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @notice Approve or revoke approval for an operator to manage all tokens\n     * @param operator Operator address\n     * @param approved True to grant approval, false to revoke\n     */\n    function setApprovalForAll(address operator, bool approved) public {\n        require(operator != msg.sender, \"ConcurrentERC721: approve to caller\");\n\n        _operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    // ============ Internal Helpers ============\n\n    /**\n     * @notice Check if token exists\n     * @param tokenId Token ID to check\n     * @return bool True if token exists\n     */\n    function _exists(uint256 tokenId) internal returns (bool) {\n        return _owners.get(tokenId) != 0;\n    }\n\n    /**\n     * @notice Check if spender is authorized to manage a token\n     * @param spender Address to check\n     * @param tokenId Token ID to check\n     * @param owner Token owner (passed to avoid redundant ownerOf call)\n     * @return bool True if spender is owner or approved\n     */\n    function _isApprovedOrOwner(\n        address spender,\n        uint256 tokenId,\n        address owner\n    ) internal returns (bool) {\n        return (spender == owner ||\n            getApproved(tokenId) == spender ||\n            isApprovedForAll(owner, spender));\n    }\n}\n\n/**\n * @title IERC721Receiver\n * @notice Interface for contracts that want to receive ERC-721 tokens via safe transfers\n */\ninterface IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
      },
      "project/contracts/TicketingCore.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@arcologynetwork/concurrentlib/lib/commutative/U256Cum.sol\";\nimport \"./ConcurrentERC721.sol\";\nimport \"./ConcurrentERC20.sol\";\n\n/**\n * @title TicketingCore\n * @notice Main event management contract for blockchain-based parallel ticketing system\n * @dev Uses Arcology's concurrent structures for parallel-safe ticket sales\n */\ncontract TicketingCore is ReentrancyGuard {\n    // Payment token used for all ticket purchases\n    ConcurrentERC20 public immutable paymentToken;\n\n    // Event counter\n    uint256 private _nextEventId;\n\n    /**\n     * @dev Tier structure for event tickets\n     * @param name Tier name (e.g., \"VIP\", \"Premium\") - also used as NFT collection name\n     * @param capacity Maximum number of tickets available in this tier\n     * @param price Price per ticket in payment tokens\n     * @param nftContract Address of the dedicated ConcurrentERC721 contract for this tier\n     */\n    struct Tier {\n        string name;\n        uint256 capacity;\n        uint256 price;\n        address nftContract;\n    }\n\n    /**\n     * @dev Event structure\n     * @param id Unique event identifier\n     * @param name Event name\n     * @param venue Event venue\n     * @param timestamp Event timestamp (Unix time)\n     * @param organizer Address of the event organizer\n     * @param tiers Dynamic array of tiers (minimum 1, recommended max 5)\n     */\n    struct Event {\n        uint256 id;\n        string name;\n        string venue;\n        uint256 timestamp;\n        address organizer;\n        Tier[] tiers;\n    }\n\n    // Mapping from event ID to Event\n    mapping(uint256 => Event) private _events;\n\n    // Concurrent state tracking - separated from view-friendly structs\n    // Mapping from eventId to revenue\n    mapping(uint256 => U256Cumulative) private _eventRevenue;\n\n    // Mapping from eventId to tierIdx to sold count\n    mapping(uint256 => mapping(uint256 => U256Cumulative)) private _tierSold;\n\n    // Events\n    event EventCreated(\n        uint256 indexed eventId,\n        string name,\n        string venue,\n        uint256 timestamp,\n        address indexed organizer,\n        uint256 tierCount\n    );\n\n    event TicketPurchased(\n        uint256 indexed eventId,\n        uint256 indexed tierIdx,\n        address indexed buyer,\n        uint256 tokenId,\n        uint256 price\n    );\n\n    event TicketRefunded(\n        uint256 indexed eventId,\n        uint256 indexed tierIdx,\n        address indexed buyer,\n        uint256 tokenId,\n        uint256 refundAmount\n    );\n\n    event RevenueWithdrawn(\n        uint256 indexed eventId,\n        address indexed organizer,\n        uint256 amount\n    );\n\n    /**\n     * @dev Constructor\n     * @param _paymentToken Address of the ERC20 token used for payments\n     */\n    constructor(address _paymentToken) {\n        require(\n            _paymentToken != address(0),\n            \"TicketingCore: payment token is zero address\"\n        );\n        paymentToken = ConcurrentERC20(_paymentToken);\n        _nextEventId = 1;\n    }\n\n    /**\n     * @dev Temporary struct for passing tier configuration during event creation\n     * @param name Tier name\n     * @param capacity Maximum tickets for this tier\n     * @param price Price per ticket in payment tokens\n     */\n    struct TierConfig {\n        string name;\n        uint256 capacity;\n        uint256 price;\n    }\n\n    /**\n     * @dev Creates a new event with dynamic tiers\n     * @param name Event name\n     * @param venue Event venue\n     * @param timestamp Event timestamp (must be >12 hours in future)\n     * @param tierConfigs Array of tier configurations (min 1, recommended max 5)\n     * @return eventId The created event ID\n     */\n    function createEvent(\n        string memory name,\n        string memory venue,\n        uint256 timestamp,\n        TierConfig[] memory tierConfigs\n    ) external returns (uint256 eventId) {\n        // Validate timestamp is >12 hours in future\n        require(\n            timestamp > block.timestamp + 12 hours,\n            \"TicketingCore: event must be >12 hours in future\"\n        );\n\n        // Validate tier count\n        require(\n            tierConfigs.length > 0,\n            \"TicketingCore: at least 1 tier required\"\n        );\n        require(\n            tierConfigs.length <= 5,\n            \"TicketingCore: max 5 tiers recommended\"\n        );\n\n        // Generate event ID\n        eventId = _nextEventId++;\n\n        // Initialize event storage\n        Event storage newEvent = _events[eventId];\n        newEvent.id = eventId;\n        newEvent.name = name;\n        newEvent.venue = venue;\n        newEvent.timestamp = timestamp;\n        newEvent.organizer = msg.sender;\n\n        // Initialize concurrent state tracking\n        _eventRevenue[eventId] = new U256Cumulative(0, type(uint256).max);\n\n        // Create tiers and deploy NFT contracts\n        for (uint256 i = 0; i < tierConfigs.length; i++) {\n            TierConfig memory config = tierConfigs[i];\n\n            // Validate tier configuration\n            require(\n                config.capacity > 0,\n                \"TicketingCore: tier capacity must be > 0\"\n            );\n            require(\n                bytes(config.name).length > 0,\n                \"TicketingCore: tier name cannot be empty\"\n            );\n\n            // Check tier name uniqueness by comparing with already added tiers\n            for (uint256 j = 0; j < i; j++) {\n                require(\n                    keccak256(bytes(tierConfigs[j].name)) !=\n                        keccak256(bytes(config.name)),\n                    \"TicketingCore: tier names must be unique\"\n                );\n            }\n\n            // Deploy dedicated ConcurrentERC721 contract for this tier\n            ConcurrentERC721 tierNFT = new ConcurrentERC721(\n                config.name,\n                \"TICKET\"\n            );\n\n            // Create tier and add to event\n            Tier memory newTier = Tier({\n                name: config.name,\n                capacity: config.capacity,\n                price: config.price,\n                nftContract: address(tierNFT)\n            });\n\n            newEvent.tiers.push(newTier);\n\n            // Initialize concurrent sold counter for this tier\n            _tierSold[eventId][i] = new U256Cumulative(0, config.capacity);\n        }\n\n        emit EventCreated(\n            eventId,\n            name,\n            venue,\n            timestamp,\n            msg.sender,\n            tierConfigs.length\n        );\n    }\n\n    /**\n     * @dev Purchase a ticket for an event\n     * @param eventId The event ID\n     * @param tierIdx The tier index to purchase from\n     * @return tokenId The minted NFT token ID\n     */\n    function purchaseTicket(\n        uint256 eventId,\n        uint256 tierIdx\n    ) external nonReentrant returns (uint256 tokenId) {\n        // Validate event exists\n        require(\n            _events[eventId].id != 0,\n            \"TicketingCore: event does not exist\"\n        );\n\n        Event storage eventData = _events[eventId];\n\n        // Validate tier index\n        require(\n            tierIdx < eventData.tiers.length,\n            \"TicketingCore: invalid tier index\"\n        );\n\n        Tier storage tier = eventData.tiers[tierIdx];\n\n        // Transfer payment from buyer to contract\n        // This will revert if buyer hasn't approved enough tokens\n        paymentToken.transferFrom(msg.sender, address(this), tier.price);\n\n        // Increment sold count - will revert if capacity exceeded (cumulative upper bound)\n        _tierSold[eventId][tierIdx].add(1);\n\n        // Increment revenue\n        _eventRevenue[eventId].add(tier.price);\n\n        // Mint NFT ticket from tier-specific collection\n        ConcurrentERC721 tierNFT = ConcurrentERC721(tier.nftContract);\n        tokenId = tierNFT.mint(msg.sender);\n\n        emit TicketPurchased(eventId, tierIdx, msg.sender, tokenId, tier.price);\n    }\n\n    /**\n     * @dev Refund a ticket before the refund deadline\n     * @param eventId The event ID\n     * @param tierIdx The tier index\n     * @param tokenId The NFT token ID to refund\n     */\n    function refundTicket(\n        uint256 eventId,\n        uint256 tierIdx,\n        uint256 tokenId\n    ) external nonReentrant {\n        // Validate event exists\n        require(\n            _events[eventId].id != 0,\n            \"TicketingCore: event does not exist\"\n        );\n\n        Event storage eventData = _events[eventId];\n\n        // Validate refund deadline\n        require(\n            block.timestamp < getRefundDeadline(eventId),\n            \"TicketingCore: refund deadline has passed\"\n        );\n\n        // Validate tier index\n        require(\n            tierIdx < eventData.tiers.length,\n            \"TicketingCore: invalid tier index\"\n        );\n\n        Tier storage tier = eventData.tiers[tierIdx];\n\n        // Get tier NFT contract\n        ConcurrentERC721 tierNFT = ConcurrentERC721(tier.nftContract);\n\n        // Verify msg.sender owns the NFT\n        require(\n            tierNFT.ownerOf(tokenId) == msg.sender,\n            \"TicketingCore: caller is not NFT owner\"\n        );\n\n        // Burn the NFT\n        tierNFT.burn(tokenId);\n\n        // Decrement sold count\n        _tierSold[eventId][tierIdx].sub(1);\n\n        // Decrement revenue\n        _eventRevenue[eventId].sub(tier.price);\n\n        // Transfer refund to buyer\n        paymentToken.transfer(msg.sender, tier.price);\n\n        emit TicketRefunded(eventId, tierIdx, msg.sender, tokenId, tier.price);\n    }\n\n    /**\n     * @dev Withdraw revenue from an event (organizer only, after refund deadline)\n     * @param eventId The event ID\n     * @param amount The amount to withdraw\n     */\n    function withdrawRevenue(\n        uint256 eventId,\n        uint256 amount\n    ) external nonReentrant {\n        // Validate event exists\n        require(\n            _events[eventId].id != 0,\n            \"TicketingCore: event does not exist\"\n        );\n\n        Event storage eventData = _events[eventId];\n\n        // Validate caller is organizer\n        require(\n            msg.sender == eventData.organizer,\n            \"TicketingCore: caller is not organizer\"\n        );\n\n        // Validate refund deadline has passed\n        require(\n            block.timestamp >= getRefundDeadline(eventId),\n            \"TicketingCore: refund deadline has not passed\"\n        );\n\n        // Deduct from revenue - will revert if amount exceeds available revenue (cumulative lower bound)\n        _eventRevenue[eventId].sub(amount);\n\n        // Transfer tokens to organizer\n        paymentToken.transfer(msg.sender, amount);\n\n        emit RevenueWithdrawn(eventId, msg.sender, amount);\n    }\n\n    /**\n     * @dev Returns the refund deadline for an event (event time - 12 hours)\n     * @param eventId The event ID\n     * @return The refund deadline timestamp\n     */\n    function getRefundDeadline(uint256 eventId) public view returns (uint256) {\n        require(\n            _events[eventId].id != 0,\n            \"TicketingCore: event does not exist\"\n        );\n        return _events[eventId].timestamp - 12 hours;\n    }\n\n    /**\n     * @dev Checks if refunds are currently allowed for an event\n     * @param eventId The event ID\n     * @return True if refunds are allowed, false otherwise\n     */\n    function canRefund(uint256 eventId) public view returns (bool) {\n        require(\n            _events[eventId].id != 0,\n            \"TicketingCore: event does not exist\"\n        );\n        return block.timestamp < getRefundDeadline(eventId);\n    }\n\n    /**\n     * @dev Gets the available revenue for withdrawal\n     * @param eventId The event ID\n     * @return The available revenue amount\n     */\n    function getAvailableRevenue(\n        uint256 eventId\n    ) public view returns (uint256) {\n        require(\n            _events[eventId].id != 0,\n            \"TicketingCore: event does not exist\"\n        );\n        return _eventRevenue[eventId].get();\n    }\n\n    /**\n     * @dev Gets tier availability information\n     * @param eventId The event ID\n     * @param tierIdx The tier index\n     * @return sold Number of tickets sold\n     * @return capacity Total capacity\n     */\n    function getTierAvailability(\n        uint256 eventId,\n        uint256 tierIdx\n    ) public view returns (uint256 sold, uint256 capacity) {\n        require(\n            _events[eventId].id != 0,\n            \"TicketingCore: event does not exist\"\n        );\n        require(\n            tierIdx < _events[eventId].tiers.length,\n            \"TicketingCore: invalid tier index\"\n        );\n\n        Tier storage tier = _events[eventId].tiers[tierIdx];\n        return (_tierSold[eventId][tierIdx].get(), tier.capacity);\n    }\n\n    /**\n     * @dev Gets complete event details\n     * @param eventId The event ID\n     * @return Event memory structure\n     */\n    function getEventDetails(\n        uint256 eventId\n    ) public view returns (Event memory) {\n        require(\n            _events[eventId].id != 0,\n            \"TicketingCore: event does not exist\"\n        );\n        return _events[eventId];\n    }\n}\n"
      }
    }
  }
}